---
layout: post
title: 重学TCP
categories: Knowledge
description: 重学TCP
keywords: TCP
---

TCP从本科起至少学习过两次，但本科课程都没太认真听，对TCP也只是有个大概的认识。之后的保研面试被问到过，但由于保研面试还是很水的，也没有太认真的复习。这两天趁着闲下来仔细的看了看TCP协议，毕竟是最重要的协议之一了，侧重点主要在三次握手四次挥手上。主要参考的博文是[这篇](https://blog.csdn.net/qq_38950316/article/details/81087809)。

## 基础知识

研究完感觉在三次握手四次挥手中，这几个基础知识是很重要的：

+ SYN（1位）：连接请求，只有在建立连接时才会设为1。

+ seq（4个字节）：本端的发送编号，与另一端所对应的接收相呼应。初始是一个设定值，在WireShark中为了方便变成了一个从0开始的相对值。seq表示本端发送的第一个数据的序列号码。

+ ack （4个字节）：接收端期望下次接收到的开始号码。通过他与seq是否相同也就保证了tcp的顺序。*为什么是下一个期望的seq号码：因为TCP是以流水线发出的，比如发送端顺序的发出 Seq=1、Seq=2、Seq=3。那么如果ACK确认的序号和收到的包的序号一致的话，那么需要发回 ACK=1、ACK=2、ACK=3 共三个包。但是TCP协议对此进行了优化，只需要发送一个ACK包就能代表说自己已经收到了前面三个包， 那就是发送ACK=4 （期望收到Seq为4的包）。这样节省了ACK确认的数量。*

+ ACK、ack、SEQ、seq：大写都是标志位，标志着这个对应的ack或seq是否是有效的。小写是具体的数值。

+ 客户端和服务器的seq和ack都是分别计算的。都是从1开始。每次发送的seq都是这一端的第一个号码，到达接收端时，接收端全部接收后ack是下一个期望开始的号码，也就会对应上发送端下一个seq的号码。如下图（[来源](https://blog.csdn.net/a19881029/article/details/38091243)）解释的很清楚：

    ![seq和ack](/images/posts/knowledge/tcp/20140725104320005.png)  
    上图客户端近向服务端发送725字节数据后，便一直等值服务端回数据，服务端每次回1448字节。

## 三次握手

![三次握手](/images/posts/knowledge/tcp/20180717202520531.png)

三次握手指的是客户端与服务端建立连接的过程，它主要的流程如下：

1. 建立连接时，客户端发送SYN包到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。即请求服务器是否可以开始传送，seq=x 指一个设定初始的序列号。

2. 服务器收到SYN包，必须确认客户的SYN（ack=x+1）下次接受的期望的就是x+1的序列号了，同时自己也发送一个SYN包（seq=y）也是一个设定的序号，即SYN+ACK包，此时服务器进入SYN_RECV状态；

3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1）下次期望接受的就是y+1的seq了，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

## 数据传送

开始传送数据。通过seq记录每次开始的数据，返回的ack确认回期望下次传的seq号。发送时为了保证有序还做了以下操作：

+ 发送方必须把已发送的数据包保留在缓冲区，并为每个已发送的数据设定一个定时器。
+ 如在定时器超时之前收到了对方发来的应答信息（*可能是对本包的应答，也可以是对本包后续包的应答。是因为如果收到后续的，接收端会自动对排序后才发回ack的，收到后续的也就表明前面的收到了，有时tcp会故意少回ack减少网络开销即累计应答包*），则释放该数据包占用的缓冲区;
+ 否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
+ 接收方收到数据包后，先进行CRC循环冗余校验(Cyclic Redundancy Check, CRC)校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

拥塞控制机制([来源](https://www.cnblogs.com/jianqingwang/p/11450992.html))：

+ 慢启动：慢启动会在网络状态不好情况下使用，具体有几个点。
    + 拥塞窗口（cwnd）：一个动态变化的窗口，慢启动的操作者。窗口值的大小就代表能够发送出去的但还没有收到ACK(Acknowledgement确认字符)的最大数据报文段。如果窗口太大可能造成网络堵塞，但如果窗口太小频繁传递效率低。所以提出了慢启动，用尝试的方法确定窗口大小。
    + 慢启动：建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量。当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下：

        >开始 ---> cwnd = 1  
        经过1个RTT后 ---> cwnd = 2*1 = 2  
        经过2个RTT后 ---> cwnd = 2*2= 4  
        经过3个RTT后 ---> cwnd = 4*2 = 8  
        如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。

+ 拥塞避免

    从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。（*简单来讲就是大到一定程度由指数增长改为线性增长*）
    为了防止cwnd增加过快而导致网络拥塞，所以需要设置一个慢开始门限ssthresh状态变量（他是一个拥塞控制的标识）,它的用法：
    + 当cwnd < ssthresh,使用慢启动算法 也就是一直*2
    + 当cwnd > ssthresh,使用拥塞控制算法，停用慢启动算法。 也就是每次+1
    + 当cwnd = ssthresh，这两个算法都可以。

+ 出现拥堵后的 加法增大，乘法减小：
    
    当出现定时器内还没有得到对应大小的数据时候，开始重传，此时证明堵塞。具体方法是：

    只要判断网络出现拥塞，就要把慢启动开始门限(ssthresh)设置为设置为发送窗口的一半，cwnd(拥塞窗口)设置为1，然后在使用慢启动算法。即此时限度成为了一半，在成倍长，到了ssthresh变成线性长。

    ![事例](/images/posts/knowledge/tcp/20160909153411895.png)