---
layout: post
title: 剑指offer
categories: Prolems
description: 剑指offer
keywords: 剑指offer,刷题
---

目录

* TOC
{:toc}

## 面试题03：数组中重复的数字 （简单）

* 题目描述

    找出数组中重复的数字。
    
    在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
    
    **示例 1:**

    >输入：  
     [2, 3, 1, 0, 2, 5, 3]  
     输出：2 或 3
     
     **限制：**
     
     >2 <= n <= 100000

* 解法

    思路1：使用 HashSet 来进行处理，因为 HashSet 本身不允许出现重复元素，所以当添加元素失败或已经包含该数字时，则表示出现了重复元素，将其返回即可。时间复杂度：O(n)，空间复杂度：O(n)
    
    思路2：从题目描述中我们可以看出，因为所有数字都在 0 ～ n-1 的范围内，其实完全可以省掉额外的空间开辟，将每个位置的数交换映射到其对应的数组下标下面，当出现新的元素与其对应的下标中的数字相等时，即为重复数字。时间复杂度：O(n)，空间复杂度：O(1)

* 代码

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> numsSet = new HashSet<>();
        for(int num: nums) {
            if(!numsSet.add(num)) {
                return num;
            }
        }
        return -1;
    }
}
```

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        for(int i=0;i<nums.length;i++){
            while(i!=nums[i]){
                if(nums[i]==nums[nums[i]]){
                    return nums[i];
                }
                int tmp = nums[i];
                nums[i] = nums[tmp];//注意这里不能写成nums[i]=nums[nums[i]],会死循环
                nums[tmp] = tmp;
            }
        }
        return -1;
    }
}
```

##  面试题04. 二维数组中的查找（简单）

* 题目描述

    在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
    
    **示例 1:**
    
    现有矩阵 matrix 如下：

    >[  
       [1,   4,  7, 11, 15],  
       [2,   5,  8, 12, 19],  
       [3,   6,  9, 16, 22],  
       [10, 13, 14, 17, 24],  
       [18, 21, 23, 26, 30]  
     ]
     
     给定 target = 5，返回 true。
     
     给定 target = 20，返回 false。
     
     **限制：**
     
     >给定 target = 5，返回 true。  
      给定 target = 20，返回 false。

* 解法

    从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

* 代码

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int row = matrix.length;
        if(matrix==null||row==0) return false;
        int col = matrix[0].length;       
        int i=0,j=col-1;
        while(i<row&&j>=0){
            if(target==matrix[i][j]){
                return true;
            }else if(target>matrix[i][j]){
                i++;
            }else{
                j--;
            }           
        }
        return false;
    }
}
```

##  面试题05. 替换空格(简单)

* 题目描述

    请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
    
    **示例 1:**

    >输入：s = "We are happy."  
     输出："We%20are%20happy."
     
     **限制：**
     
     >0 <= s 的长度 <= 10000

* 解法

    由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。

* 代码

```java
class Solution {
    public String replaceSpace(String s) {
        int length = s.length();
        char[] array = new char[length * 3];
        int size = 0;
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            if (c == ' ') {
                array[size++] = '%';
                array[size++] = '2';
                array[size++] = '0';
            } else {
                array[size++] = c;
            }
        }
        String newStr = new String(array, 0, size);
        return newStr;
    }
}
```

```java
class Solution {
    public String replaceSpace(String s) {
        s=s.replaceAll(" ","%20");
        return s;
    }
}
```

##  面试题06. 从尾到头打印链表(简单)

* 题目描述

    输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
    
    **示例 1:**

    >输入：head = [1,3,2]  
     输出：[2,3,1]
     
     **限制：**
     
     >0 <= 链表长度 <= 10000

* 解法

    这题本身没难度，栈或者递归，第二个解法试了下stream，效率极低

* 代码

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        if(head==null) return new int[0];
        ListNode node = head;
        Stack<ListNode> stack = new Stack<>();
        while(node!=null){
            stack.push(node);
            node = node.next;
        }
        int[] result = new int[stack.size()];
        int i=0;
        while(!stack.isEmpty()){
            result[i++] = stack.pop().val;
        }
        return result;
    }
}
```

```java
class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    public int[] reversePrint(ListNode head) {
        if(head==null) return new int[0];
        recur(head);
        int[] result = list.stream().mapToInt(Integer::valueOf).toArray();
        return result;
    }

    public void recur(ListNode tmp){
        if(tmp.next!=null){
            reversePrint(tmp.next);
        }
        list.add(tmp.val);
    }
}
```

```java
class Solution {
    ArrayList<Integer> tmp = new ArrayList<Integer>();
    public int[] reversePrint(ListNode head) {
        recur(head);
        int[] res = new int[tmp.size()];
        for(int i = 0; i < res.length; i++)
            res[i] = tmp.get(i);
        return res;
    }
    void recur(ListNode head) {
        if(head == null) return;
        recur(head.next);
        tmp.add(head.val);
    }
}
```

##  面试题07. 重建二叉树（中等）

* 题目描述

    输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
    
    **示例 1:**

    >前序遍历 preorder = [3,9,20,15,7]  
     中序遍历 inorder = [9,3,15,20,7]
     
    **限制：**
     
    >0 <= 节点个数 <= 5000

* 解法

    前序得到根节点，去中序那得到根节点下标，左边是中序的左子树，右边是右子树，递归创建

* 代码

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder==null||preorder.length==0){
            return null;
        }
        int rootNum = preorder[0];
        TreeNode tmpNode = new TreeNode(rootNum);
        int rootIndex = 0;
        for(int i=0;i<inorder.length;i++){
            if(rootNum==inorder[i]){
                rootIndex = i;
            }
        }
        int[] preorderLeft = Arrays.copyOfRange(preorder,1,1+rootIndex);
        int[] inorderLeft = Arrays.copyOfRange(inorder,0,rootIndex);
        int[] preorderRight = Arrays.copyOfRange(preorder,1+rootIndex,preorder.length);
        int[] inorderRight = Arrays.copyOfRange(inorder,1+rootIndex,inorder.length);
        tmpNode.left = buildTree(preorderLeft,inorderLeft);
        tmpNode.right = buildTree(preorderRight,inorderRight);
        return tmpNode;
    }
}
```

##  面试题09. 用两个栈实现队列（简单）

* 题目描述

    用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
    
    **示例 1:**

    >输入：
     ["CQueue","appendTail","deleteHead","deleteHead"]  
     [[],[3],[],[]]  
     输出：[null,null,3,-1]
     
    **限制：**
     
    >1 <= values <= 10000  
     最多会对 appendTail、deleteHead 进行 10000 次调用

* 解法

    出栈前，判断一下，把一个栈扔到另外一个里

* 代码

```java
class CQueue {
    public Stack<Integer> stack1;
    public Stack<Integer> stack2;
    public CQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        stack1.push(value);
    }
    
    public int deleteHead() {
        if(!stack2.isEmpty()){
            return stack2.pop();
        }else if(stack1.isEmpty()){
            return -1;
        }else{
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
            return stack2.pop();
        }
    }
}
```

##  面试题10- I. 斐波那契数（简单）

* 题目描述

    写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：F(0) = 0,   F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1.答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
    
    **示例 1:**

    >输入：n = 5  
     输出：5
     
    **限制：**
     
    >0 <= n <= 100

* 解法

    注意斐波那契变种题即可

* 代码

```java
class Solution {
    public int fib(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        int[] result = new int[n+1];
        result[0]=0;
        result[1]=1;
        for(int i=2;i<n+1;i++){
            result[i]=(result[i-1]+result[i-2])% 1000000007;
        }
        return result[n];
    }
}
```

##  面试题10- II. 青蛙跳台阶问题（简单）

* 题目描述

    一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
    
    答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
    
    **示例 1:**

    >输入：n = 2  
     输出：2
     
    **限制：**
     
    >0 <= n <= 100

* 解法

    斐波那契变种

* 代码

```java
class Solution {
    public int numWays(int n) {
        if(n==0) return 1;
        if(n==1) return 1;
        if(n==2) return 2;
        int a=1,b=2;
        int result=0;
        for(int i=3;i<n+1;i++){
            result=(a+b)%1000000007;
            a=b;
            b=result;
        }
        return result;
    }
}
```

##  面试题11. 旋转数组的最小数字（简单）

* 题目描述

    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
    
    **示例 1:**

    >输入：[3,4,5,1,2]   
     输出：1
     
    **示例 2:**
    
    >输入：[2,2,2,0,1]  
     输出：0

* 解法

    二分法，重点！减治思想
    
    用左边位置 left 和中间位置 mid 的值进行比较是否可以？  
    举例：[3, 4, 5, 1, 2] 与 [1, 2, 3, 4, 5] ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不能有效地减治。
    
    用右边位置 right 和中间位置 mid 的值进行比较是否可以？  
    举例：[1, 2, 3, 4, 5]、[3, 4, 5, 1, 2]、[2, 3, 4, 5 ,1]，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。
    
    补充说明：遇到 nums[mid] == nums[right] 的时候，不能草率地下定结论最小数字在哪一边，但是可以确定的是，把 right 舍弃掉，并不影响结果。

* 代码

```java
class Solution {
    public int minArray(int[] numbers) {
        int low=0;
        int high=numbers.length-1;
        int mid=0;
        while(low<high){
            mid=low+(high-low)/2;
            if(numbers[mid]>numbers[high]){
                low=mid+1;
            }else if(numbers[mid]==numbers[high]){
                high=high-1;
            }else{
                high=mid;
            }
        }
        return numbers[low];
    }
}
```

##  面试题12. 矩阵中的路径（中等）

* 题目描述

    请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
    
    [["a","b","c","e"],  
    ["s","f","c","s"],  
    ["a","d","e","e"]]
    
    但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
    
    **示例 1:**

    >输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"  
     输出：true
     
    **限制：**
     
    >1 <= board.length <= 200  
     1 <= board[i].length <= 200

* 解法

    解法1：路径问题一般需要visit来存储是否访问过，由于每个点都可以是起点，所以在两个for循环中使用回溯。在回溯内部，上下左右走是递归的入口，如果能走返回true
    
    解法2：深度优先搜索（DFS）+ 剪枝 解决。
    
    * 深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
    * 剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素值和目标字符值不同、路径已访问此元素），则应立即返回，称之为 可行性剪枝 。

* 代码

```java
class Solution {
    boolean[] visited;
    public boolean exist(char[][] board, String word) {
        int row=board.length;
        int col=board[0].length;
        boolean result=false;
        visited = new boolean[row*col];
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                result = result||existCore(board,i,j,word,0);
            }
        }
        return result;
    }

    public boolean existCore(char[][] board,int row,int col,String word,int index){
        int rowLen=board.length;
        int colLen=board[0].length;
        if(board[row][col]!=word.charAt(index)||visited[row*colLen+col]){
            return false;
        }
        if(board[row][col]==word.charAt(index)&&index==word.length()-1){
            return true;
        }
        visited[row*colLen+col]=true;
        if(row>0&&existCore(board,row-1,col,word,index+1)) return true;
        if(row<rowLen-1&&existCore(board,row+1,col,word,index+1)) return true;
        if(col>0&&existCore(board,row,col-1,word,index+1)) return true;
        if(col<colLen-1&&existCore(board,row,col+1,word,index+1)) return true;
        visited[row*colLen+col]=false;
        return false;
    }
}
```

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, words, i, j, 0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;
        if(k == word.length - 1) return true;
        char tmp = board[i][j];
        board[i][j] = '/';
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = tmp;
        return res;
    }
}
```

##  面试题13. 机器人的运动范围（中等）

* 题目描述

    地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
    
    **示例 1:**

    >输入：m = 2, n = 3, k = 1  
     输出：3
     
    **限制：**
     
    >1 <= n,m <= 100  
     0 <= k <= 20

* 解法

    使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。

* 代码

```java
public class Solution {
     
    int result=0;
    boolean[] visited = null;
    public int movingCount(int threshold, int rows, int cols)
    {
        visited = new boolean[rows*cols];
        countCore(threshold,rows,cols,0,0);
        return result;
    }
     
    public void countCore(int threshold,int rows,int cols,int row,int col){
        boolean judgeD=judgeDigit(threshold,row,col);
        if(!judgeD||visited[row*cols+col]){
            return;
        }
        result++;
        visited[row*cols+col]=true;
        if(row>0) countCore(threshold,rows,cols,row-1,col);
        if(row<rows-1) countCore(threshold,rows,cols,row+1,col);
        if(col>0) countCore(threshold,rows,cols,row,col-1);
        if(col<cols-1) countCore(threshold,rows,cols,row,col+1);
    }
     
    public boolean judgeDigit(int threshold,int row,int col){
        int count=0;
        while(row>0){
            count+=row%10;
            row/=10;
        }
        while(col>0){
            count+=col%10;
            col/=10;
        }
        if(count>threshold){
            return false;
        }else{
            return true;
        }
    }
}

```

##  面试题14- I. 剪绳子（中等）

* 题目描述

    给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
    
    **示例 1:**

    >输入: 10  
     输出: 36  
     解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
     
    **限制：**
     
    >2 <= n <= 58

* 解法

    贪心规则：    
    * 最高优先级： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。
    * 次高优先级： 2 。若最后一段绳子长度为 2，则保留，不再拆为 1+1 。
    * 最低优先级： 1； 若最后一段绳子长度为 1；则应把最后的 3 + 1 替换为 2 + 2，因为 2×2>3×1
    
    如果需要对结果取模运算，需要对每一步取模，不然会溢出

* 代码

```java
class Solution {
    public int cuttingRope(int n) {
        if(n<=3) return n-1;
        int a=n/3;
        int b=n%3;
        if(b==0) return (int)Math.pow(3,a);
        if(b==1) return (int)Math.pow(3,a-1)*4;
        return (int)Math.pow(3,a)*2;
    }
}
```

```java
class Solution {
    public int cuttingRope(int n) {
        if(n == 2) {
            return 1;
        }
        if(n == 3){
            return 2;
        }
        int mod = (int)1e9 + 7;
        long res = 1;
        while(n > 4) {
            res *= 3;
            res %= mod;
            n -= 3;
        }
        return (int)(res * n % mod);
    }
}
```

##  面试题15. 二进制中1的个数（简单）

* 题目描述

    请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
    
    **示例 1:**

    >输入：00000000000000000000000000001011  
     输出：3  
     解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
     
    **示例 2：**
     
    >输入：11111111111111111111111111111101  
     输出：31  
     解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

* 解法

    依次判断整数的每一位是否为 1 。

* 代码

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        while(n!=0){
            count+=(n&1);
            n=n>>>1;//无符号右移，忽略符号位，空位都以0补齐
        }
        return count;
    }
}
```

##  面试题16. 数值的整数次方（中等）

* 题目描述

    实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。
    
    **示例 1:**

    >输入: 2.00000, 10  
     输出: 1024.00000
     
    **限制：**
     
    >-100.0 < x < 100.0  
     n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

* 解法

    要注意的一点是，虽然题目中告诉我们不需要考虑大数问题，但是给出的 n 可以取到 -2147483648−2147483648（整型负数的最小值），因此，在编码的时候，需要将 n 转换成 long 类型。因为abs(INT_MIN) 比 INT_MAX 大1， 所以不能直接用 -n

    写法一：递归写法（分治思想）
    
    写法二：非递归写法（将指数看成二进制数）把指数 n 做“二进制分解”，在底数不断自身乘以自身的过程中，将最终结果需要的部分保存下来。
    
    ![offer16](/images/posts/problems/offer/offer16.png)
    
* 代码

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        if(n<0){
            x=1/x;
            return myPow(x,-N);
        }
        return myPow(x,N);
    }
    public double myPow(double x,long N){
        if(N==0||x==1) return 1.0;
        // 根据指数是奇数还是偶数进行分类讨论
        // 使用位运算的 与 运算符代替了求余数运算
        if((N&1)==0){
            double square = myPow(x,N>>>1);// 分治思想：分
            return square*square;// 分治思想：合
        }else{
            double square = myPow(x,(N-1)>>>1);
            return square*square*x;
        }
    }
}
```

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        if(n<0){
            x=1/x;
            N*=-1;
        }
        double result=1;
        while(N>0){
            if((N&1)==1){
                result*=x;
            }
            x*=x;
            N>>>=1;
        }
        return result;
    }
}
```

##  面试题17. 打印从1到最大的n位数（简单）

* 题目描述

    输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
    
    **示例 1:**

    >输入: n = 1  
     输出: [1,2,3,4,5,6,7,8,9]
     
    **说明：**
     
    >用返回一个整数列表来代替打印  
     n 为正整数

* 代码

```java
class Solution {
    public int[] printNumbers(int n) {
        int max=(int)Math.pow(10,n);
        int[] result = new int[max-1];
        for(int i=1;i<max;i++){
            result[i-1]=i;
        }
        return result;
    }
}
```

##  面试题18. 删除链表的节点（简单）

* 题目描述

    给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
    
    返回删除后的链表的头节点。
    
    注意：此题对比原题有改动
    
    **示例 1:**

    >输入: head = [4,5,1,9], val = 5  
     输出: [4,1,9]  
     解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
     
    **说明：**
     
    >题目保证链表中节点的值互不相同  
     若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点

* 解法

    

* 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode tmp = head;
        if(head.val==val) return head.next;
        while(tmp!=null){
            if(tmp.next.val==val){
                tmp.next=tmp.next.next;
                break;
            }
            tmp=tmp.next;
        }
        return head;
    }
}
```

##  （）

* 题目描述

    
    
    **示例 1:**

    >
     
    **限制：**
     
    >

* 解法

    

* 代码

```java

```