---
layout: post
title: 剑指offer
categories: Prolems
description: 剑指offer
keywords: 剑指offer,刷题
---

目录

* TOC
{:toc}

## 面试题03：数组中重复的数字 （简单）

* 题目描述

    找出数组中重复的数字。
    
    在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
    
    **示例 1:**

    >输入：  
     [2, 3, 1, 0, 2, 5, 3]  
     输出：2 或 3
     
     **限制：**
     
     >2 <= n <= 100000

* 解法

    思路1：使用 HashSet 来进行处理，因为 HashSet 本身不允许出现重复元素，所以当添加元素失败或已经包含该数字时，则表示出现了重复元素，将其返回即可。时间复杂度：O(n)，空间复杂度：O(n)
    
    思路2：从题目描述中我们可以看出，因为所有数字都在 0 ～ n-1 的范围内，其实完全可以省掉额外的空间开辟，将每个位置的数交换映射到其对应的数组下标下面，当出现新的元素与其对应的下标中的数字相等时，即为重复数字。时间复杂度：O(n)，空间复杂度：O(1)

* 代码

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> numsSet = new HashSet<>();
        for(int num: nums) {
            if(!numsSet.add(num)) {
                return num;
            }
        }
        return -1;
    }
}
```

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        for(int i=0;i<nums.length;i++){
            while(i!=nums[i]){
                if(nums[i]==nums[nums[i]]){
                    return nums[i];
                }
                int tmp = nums[i];
                nums[i] = nums[tmp];//注意这里不能写成nums[i]=nums[nums[i]],会死循环
                nums[tmp] = tmp;
            }
        }
        return -1;
    }
}
```

##  面试题04. 二维数组中的查找（简单）

* 题目描述

    在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
    
    **示例 1:**
    
    现有矩阵 matrix 如下：

    >[  
       [1,   4,  7, 11, 15],  
       [2,   5,  8, 12, 19],  
       [3,   6,  9, 16, 22],  
       [10, 13, 14, 17, 24],  
       [18, 21, 23, 26, 30]  
     ]
     
     给定 target = 5，返回 true。
     
     给定 target = 20，返回 false。
     
     **限制：**
     
     >给定 target = 5，返回 true。  
      给定 target = 20，返回 false。

* 解法

    从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

* 代码

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int row = matrix.length;
        if(matrix==null||row==0) return false;
        int col = matrix[0].length;       
        int i=0,j=col-1;
        while(i<row&&j>=0){
            if(target==matrix[i][j]){
                return true;
            }else if(target>matrix[i][j]){
                i++;
            }else{
                j--;
            }           
        }
        return false;
    }
}
```

##  面试题05. 替换空格(简单)

* 题目描述

    请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
    
    **示例 1:**

    >输入：s = "We are happy."  
     输出："We%20are%20happy."
     
     **限制：**
     
     >0 <= s 的长度 <= 10000

* 解法

    由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。

* 代码

```java
class Solution {
    public String replaceSpace(String s) {
        int length = s.length();
        char[] array = new char[length * 3];
        int size = 0;
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            if (c == ' ') {
                array[size++] = '%';
                array[size++] = '2';
                array[size++] = '0';
            } else {
                array[size++] = c;
            }
        }
        String newStr = new String(array, 0, size);
        return newStr;
    }
}
```

```java
class Solution {
    public String replaceSpace(String s) {
        s=s.replaceAll(" ","%20");
        return s;
    }
}
```

##  面试题06. 从尾到头打印链表(简单)

* 题目描述

    输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
    
    **示例 1:**

    >输入：head = [1,3,2]  
     输出：[2,3,1]
     
     **限制：**
     
     >0 <= 链表长度 <= 10000

* 解法

    这题本身没难度，栈或者递归，第二个解法试了下stream，效率极低

* 代码

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        if(head==null) return new int[0];
        ListNode node = head;
        Stack<ListNode> stack = new Stack<>();
        while(node!=null){
            stack.push(node);
            node = node.next;
        }
        int[] result = new int[stack.size()];
        int i=0;
        while(!stack.isEmpty()){
            result[i++] = stack.pop().val;
        }
        return result;
    }
}
```

```java
class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    public int[] reversePrint(ListNode head) {
        if(head==null) return new int[0];
        recur(head);
        int[] result = list.stream().mapToInt(Integer::valueOf).toArray();
        return result;
    }

    public void recur(ListNode tmp){
        if(tmp.next!=null){
            reversePrint(tmp.next);
        }
        list.add(tmp.val);
    }
}
```

```java
class Solution {
    ArrayList<Integer> tmp = new ArrayList<Integer>();
    public int[] reversePrint(ListNode head) {
        recur(head);
        int[] res = new int[tmp.size()];
        for(int i = 0; i < res.length; i++)
            res[i] = tmp.get(i);
        return res;
    }
    void recur(ListNode head) {
        if(head == null) return;
        recur(head.next);
        tmp.add(head.val);
    }
}
```

##  面试题07. 重建二叉树（中等）

* 题目描述

    输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
    
    **示例 1:**

    >前序遍历 preorder = [3,9,20,15,7]  
     中序遍历 inorder = [9,3,15,20,7]
     
    **限制：**
     
    >0 <= 节点个数 <= 5000

* 解法

    前序得到根节点，去中序那得到根节点下标，左边是中序的左子树，右边是右子树，递归创建

* 代码

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder==null||preorder.length==0){
            return null;
        }
        int rootNum = preorder[0];
        TreeNode tmpNode = new TreeNode(rootNum);
        int rootIndex = 0;
        for(int i=0;i<inorder.length;i++){
            if(rootNum==inorder[i]){
                rootIndex = i;
            }
        }
        int[] preorderLeft = Arrays.copyOfRange(preorder,1,1+rootIndex);
        int[] inorderLeft = Arrays.copyOfRange(inorder,0,rootIndex);
        int[] preorderRight = Arrays.copyOfRange(preorder,1+rootIndex,preorder.length);
        int[] inorderRight = Arrays.copyOfRange(inorder,1+rootIndex,inorder.length);
        tmpNode.left = buildTree(preorderLeft,inorderLeft);
        tmpNode.right = buildTree(preorderRight,inorderRight);
        return tmpNode;
    }
}
```

##  面试题09. 用两个栈实现队列（简单）

* 题目描述

    用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
    
    **示例 1:**

    >输入：
     ["CQueue","appendTail","deleteHead","deleteHead"]  
     [[],[3],[],[]]  
     输出：[null,null,3,-1]
     
    **限制：**
     
    >1 <= values <= 10000  
     最多会对 appendTail、deleteHead 进行 10000 次调用

* 解法

    出栈前，判断一下，把一个栈扔到另外一个里

* 代码

```java
class CQueue {
    public Stack<Integer> stack1;
    public Stack<Integer> stack2;
    public CQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        stack1.push(value);
    }
    
    public int deleteHead() {
        if(!stack2.isEmpty()){
            return stack2.pop();
        }else if(stack1.isEmpty()){
            return -1;
        }else{
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
            return stack2.pop();
        }
    }
}
```

##  面试题10- I. 斐波那契数（简单）

* 题目描述

    写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：F(0) = 0,   F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1.答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
    
    **示例 1:**

    >输入：n = 5  
     输出：5
     
    **限制：**
     
    >0 <= n <= 100

* 解法

    注意斐波那契变种题即可

* 代码

```java
class Solution {
    public int fib(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        int[] result = new int[n+1];
        result[0]=0;
        result[1]=1;
        for(int i=2;i<n+1;i++){
            result[i]=(result[i-1]+result[i-2])% 1000000007;
        }
        return result[n];
    }
}
```

##  面试题10- II. 青蛙跳台阶问题（简单）

* 题目描述

    一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
    
    答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
    
    **示例 1:**

    >输入：n = 2  
     输出：2
     
    **限制：**
     
    >0 <= n <= 100

* 解法

    斐波那契变种

* 代码

```java
class Solution {
    public int numWays(int n) {
        if(n==0) return 1;
        if(n==1) return 1;
        if(n==2) return 2;
        int a=1,b=2;
        int result=0;
        for(int i=3;i<n+1;i++){
            result=(a+b)%1000000007;
            a=b;
            b=result;
        }
        return result;
    }
}
```

##  面试题11. 旋转数组的最小数字（简单）

* 题目描述

    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
    
    **示例 1:**

    >输入：[3,4,5,1,2]   
     输出：1
     
    **示例 2:**
    
    >输入：[2,2,2,0,1]  
     输出：0

* 解法

    二分法，重点！减治思想
    
    用左边位置 left 和中间位置 mid 的值进行比较是否可以？  
    举例：[3, 4, 5, 1, 2] 与 [1, 2, 3, 4, 5] ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不能有效地减治。
    
    用右边位置 right 和中间位置 mid 的值进行比较是否可以？  
    举例：[1, 2, 3, 4, 5]、[3, 4, 5, 1, 2]、[2, 3, 4, 5 ,1]，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。
    
    补充说明：遇到 nums[mid] == nums[right] 的时候，不能草率地下定结论最小数字在哪一边，但是可以确定的是，把 right 舍弃掉，并不影响结果。

* 代码

```java
class Solution {
    public int minArray(int[] numbers) {
        int low=0;
        int high=numbers.length-1;
        int mid=0;
        while(low<high){
            mid=low+(high-low)/2;
            if(numbers[mid]>numbers[high]){
                low=mid+1;
            }else if(numbers[mid]==numbers[high]){
                high=high-1;
            }else{
                high=mid;
            }
        }
        return numbers[low];
    }
}
```

##  面试题12. 矩阵中的路径（中等）

* 题目描述

    请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
    
    [["a","b","c","e"],  
    ["s","f","c","s"],  
    ["a","d","e","e"]]
    
    但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
    
    **示例 1:**

    >输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"  
     输出：true
     
    **限制：**
     
    >1 <= board.length <= 200  
     1 <= board[i].length <= 200

* 解法

    解法1：路径问题一般需要visit来存储是否访问过，由于每个点都可以是起点，所以在两个for循环中使用回溯。在回溯内部，上下左右走是递归的入口，如果能走返回true
    
    解法2：深度优先搜索（DFS）+ 剪枝 解决。
    
    * 深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
    * 剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素值和目标字符值不同、路径已访问此元素），则应立即返回，称之为 可行性剪枝 。

* 代码

```java
class Solution {
    boolean[] visited;
    public boolean exist(char[][] board, String word) {
        int row=board.length;
        int col=board[0].length;
        boolean result=false;
        visited = new boolean[row*col];
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                result = result||existCore(board,i,j,word,0);
            }
        }
        return result;
    }

    public boolean existCore(char[][] board,int row,int col,String word,int index){
        int rowLen=board.length;
        int colLen=board[0].length;
        if(board[row][col]!=word.charAt(index)||visited[row*colLen+col]){
            return false;
        }
        if(board[row][col]==word.charAt(index)&&index==word.length()-1){
            return true;
        }
        visited[row*colLen+col]=true;
        if(row>0&&existCore(board,row-1,col,word,index+1)) return true;
        if(row<rowLen-1&&existCore(board,row+1,col,word,index+1)) return true;
        if(col>0&&existCore(board,row,col-1,word,index+1)) return true;
        if(col<colLen-1&&existCore(board,row,col+1,word,index+1)) return true;
        visited[row*colLen+col]=false;
        return false;
    }
}
```

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, words, i, j, 0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;
        if(k == word.length - 1) return true;
        char tmp = board[i][j];
        board[i][j] = '/';
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = tmp;
        return res;
    }
}
```

##  面试题13. 机器人的运动范围（中等）

* 题目描述

    地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
    
    **示例 1:**

    >输入：m = 2, n = 3, k = 1  
     输出：3
     
    **限制：**
     
    >1 <= n,m <= 100  
     0 <= k <= 20

* 解法

    使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。

* 代码

```java
public class Solution {
     
    int result=0;
    boolean[] visited = null;
    public int movingCount(int threshold, int rows, int cols)
    {
        visited = new boolean[rows*cols];
        countCore(threshold,rows,cols,0,0);
        return result;
    }
     
    public void countCore(int threshold,int rows,int cols,int row,int col){
        boolean judgeD=judgeDigit(threshold,row,col);
        if(!judgeD||visited[row*cols+col]){
            return;
        }
        result++;
        visited[row*cols+col]=true;
        if(row>0) countCore(threshold,rows,cols,row-1,col);
        if(row<rows-1) countCore(threshold,rows,cols,row+1,col);
        if(col>0) countCore(threshold,rows,cols,row,col-1);
        if(col<cols-1) countCore(threshold,rows,cols,row,col+1);
    }
     
    public boolean judgeDigit(int threshold,int row,int col){
        int count=0;
        while(row>0){
            count+=row%10;
            row/=10;
        }
        while(col>0){
            count+=col%10;
            col/=10;
        }
        if(count>threshold){
            return false;
        }else{
            return true;
        }
    }
}

```

##  面试题14- I. 剪绳子（中等）

* 题目描述

    给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
    
    **示例 1:**

    >输入: 10  
     输出: 36  
     解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
     
    **限制：**
     
    >2 <= n <= 58

* 解法

    贪心规则：    
    * 最高优先级： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。
    * 次高优先级： 2 。若最后一段绳子长度为 2，则保留，不再拆为 1+1 。
    * 最低优先级： 1； 若最后一段绳子长度为 1；则应把最后的 3 + 1 替换为 2 + 2，因为 2×2>3×1
    
    如果需要对结果取模运算，需要对每一步取模，不然会溢出

* 代码

```java
class Solution {
    public int cuttingRope(int n) {
        if(n<=3) return n-1;
        int a=n/3;
        int b=n%3;
        if(b==0) return (int)Math.pow(3,a);
        if(b==1) return (int)Math.pow(3,a-1)*4;
        return (int)Math.pow(3,a)*2;
    }
}
```

```java
class Solution {
    public int cuttingRope(int n) {
        if(n == 2) {
            return 1;
        }
        if(n == 3){
            return 2;
        }
        int mod = (int)1e9 + 7;
        long res = 1;
        while(n > 4) {
            res *= 3;
            res %= mod;
            n -= 3;
        }
        return (int)(res * n % mod);
    }
}
```

##  面试题15. 二进制中1的个数（简单）

* 题目描述

    请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
    
    **示例 1:**

    >输入：00000000000000000000000000001011  
     输出：3  
     解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
     
    **示例 2：**
     
    >输入：11111111111111111111111111111101  
     输出：31  
     解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

* 解法

    依次判断整数的每一位是否为 1 。

* 代码

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        while(n!=0){
            count+=(n&1);
            n=n>>>1;//无符号右移，忽略符号位，空位都以0补齐
        }
        return count;
    }
}
```

##  面试题16. 数值的整数次方（中等）

* 题目描述

    实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。
    
    **示例 1:**

    >输入: 2.00000, 10  
     输出: 1024.00000
     
    **限制：**
     
    >-100.0 < x < 100.0  
     n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

* 解法

    要注意的一点是，虽然题目中告诉我们不需要考虑大数问题，但是给出的 n 可以取到 -2147483648−2147483648（整型负数的最小值），因此，在编码的时候，需要将 n 转换成 long 类型。因为abs(INT_MIN) 比 INT_MAX 大1， 所以不能直接用 -n

    写法一：递归写法（分治思想）
    
    写法二：非递归写法（将指数看成二进制数）把指数 n 做“二进制分解”，在底数不断自身乘以自身的过程中，将最终结果需要的部分保存下来。
    
    ![offer16](/images/posts/problems/offer/offer16.png)
    
* 代码

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        if(n<0){
            x=1/x;
            return myPow(x,-N);
        }
        return myPow(x,N);
    }
    public double myPow(double x,long N){
        if(N==0||x==1) return 1.0;
        // 根据指数是奇数还是偶数进行分类讨论
        // 使用位运算的 与 运算符代替了求余数运算
        if((N&1)==0){
            double square = myPow(x,N>>>1);// 分治思想：分
            return square*square;// 分治思想：合
        }else{
            double square = myPow(x,(N-1)>>>1);
            return square*square*x;
        }
    }
}
```

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        if(n<0){
            x=1/x;
            N*=-1;
        }
        double result=1;
        while(N>0){
            if((N&1)==1){
                result*=x;
            }
            x*=x;
            N>>>=1;
        }
        return result;
    }
}
```

##  面试题17. 打印从1到最大的n位数（简单）

* 题目描述

    输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
    
    **示例 1:**

    >输入: n = 1  
     输出: [1,2,3,4,5,6,7,8,9]
     
    **说明：**
     
    >用返回一个整数列表来代替打印  
     n 为正整数

* 代码

```java
class Solution {
    public int[] printNumbers(int n) {
        int max=(int)Math.pow(10,n);
        int[] result = new int[max-1];
        for(int i=1;i<max;i++){
            result[i-1]=i;
        }
        return result;
    }
}
```

##  面试题18. 删除链表的节点（简单）

* 题目描述

    给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
    
    返回删除后的链表的头节点。
    
    注意：此题对比原题有改动
    
    **示例 1:**

    >输入: head = [4,5,1,9], val = 5  
     输出: [4,1,9]  
     解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
     
    **说明：**
     
    >题目保证链表中节点的值互不相同  
     若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点

* 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode tmp = head;
        if(head.val==val) return head.next;
        while(tmp!=null){
            if(tmp.next.val==val){
                tmp.next=tmp.next.next;
                break;
            }
            tmp=tmp.next;
        }
        return head;
    }
}
```

##  面试题20. 表示数值的字符串（中等）

* 题目描述

    请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"及"-1E-16"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

* 解法

    1)A[.[B]][e|EC]  2).B[e|EC]; 其中,A、C是整数，B是正整数

* 代码

```java
/*
核心: 有效数字的模式有两种:1)A[.[B]][e|EC]  2).B[e|EC]; 其中,A、C是整数，B是正整数
有A的话,有没有B都可以
没有A的话, 必须有B
*/
class Solution {
    //扫描字符串时的索引
    int i=0;
    public boolean isNumber(String s) {
        //input check
        if(s==null || s.length()==0)
            return false;
        //去掉首尾的空字符
        s = s.trim();
        boolean A = scanInteger(s), B=false, C=false;
        //判断是否有B; 使用索引时要确保索引不越界
        if(i<s.length() && s.charAt(i)=='.'){
            i++;
            B = scanUnsignedInteger(s);
        }
        //判断是否有C
        if(i<s.length() && (s.charAt(i)=='e' || s.charAt(i)=='E')){
            i++;
            C = scanInteger(s);
            //如果存在e|E, 但是没有C, 说明不是数字
            if(C==false)
                return false;
        }
        //here, 说明C是合格的, 只需判断A和B的情况
        //i必须扫描完整个字符串 && (A合格则B合不合格都可以, A不合格则B必须合格)
        return i==s.length() && (A || B);
        
    }
    private boolean scanInteger(String s){
        if(i<s.length() && (s.charAt(i)=='+' || s.charAt(i)=='-'))
            i++;
        return scanUnsignedInteger(s);
    }
    private boolean scanUnsignedInteger(String s){
        //起始索引
        int start = i;
        while(i<s.length() && s.charAt(i)>='0' && s.charAt(i)<='9'){
            i++;
        }
        //i>start说明扫描到了数字; 
        //i<=start说明没有扫描到数字, 此种情况说明要么start越界, 要么s.charAt(start)不是数字
        return i > start;
    }
}
```

##  面试题21. 调整数组顺序使奇数位于偶数前面（简单）

* 题目描述

    输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
    
    **示例 1:**

    >输入：nums = [1,2,3,4]  
     输出：[1,3,2,4]  
     注：[3,1,2,4] 也是正确的答案之一。
     
    **限制：**
     
    >1 <= nums.length <= 50000  
     1 <= nums[i] <= 10000

* 解法

    头尾指针，指向排好的奇数和偶数

* 代码

```java
class Solution {
    public int[] exchange(int[] nums) {
        int oddIndex=0;
        int evenIndex=nums.length-1;
        while(oddIndex<evenIndex){
            if((nums[oddIndex]&1)==1){
                oddIndex++;
            }else{
                swap(nums,oddIndex,evenIndex);
                evenIndex--;
            }
        }
        return nums;
    }

    public void swap(int[] nums,int i,int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

##  面试题22. 链表中倒数第k个节点（简单）

* 题目描述

    输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
    
    **示例 1:**

    >给定一个链表: 1->2->3->4->5, 和 k = 2.  
     返回链表 4->5.

* 解法

    快慢指针，快的先走k步

* 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode preNode = head;
        for(int i=0;i<k;i++){
            preNode = preNode.next;
        }
        ListNode resNode = head;
        while(preNode!=null){
            preNode = preNode.next;
            resNode = resNode.next;
        }
        return resNode;
    }
}
```

##  面试题24. 反转链表（简单）

* 题目描述

    定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
    
    **示例 1:**

    >输入: 1->2->3->4->5->NULL  
     输出: 5->4->3->2->1->NULL
     
    **限制：**
     
    >0 <= 节点个数 <= 5000

* 解法

    循环，记录好上一个

* 代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur!=null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

##  面试题25. 合并两个排序的链表（简单）

* 题目描述

    输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
    
    **示例 1:**

    >输入：1->2->4, 1->3->4  
     输出：1->1->2->3->4->4
     
    **限制：**
     
    >0 <= 链表长度 <= 1000

* 解法

    递归，值小的链表的下一个递归，并且往后走一个
    
    循环，利用一下dummyNode即可

* 代码

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    }
}
```
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0), p = dummy;

    while (l1 != null && l2 != null) {
      if (l1.val < l2.val) {
        p.next = l1;
        l1 = l1.next;
      } else {
        p.next = l2;
        l2 = l2.next;
      }
      p = p.next;
    }

    if (l1 != null) p.next = l1;
    if (l2 != null) p.next = l2;
    return dummy.next;
    }
}
```

##  面试题26. 树的子结构（）

* 题目描述

    输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
    
    B是A的子结构， 即 A中有出现和B相同的结构和节点值。
    
    **示例 1:**

    >输入：A = [1,2,3], B = [3,1]  
     输出：false
     
    **示例 2：**
     
    >输入：A = [3,4,5,1,2], B = [4,1]  
     输出：true

* 解法

    大的那棵树为进入条件，如果值相等，进子函数，不相等大的树进孩子节点遍历找入口
    
    子函数，递归进左右节点，判断是否都一样

* 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        boolean result = false;
        if(A!=null&&B!=null){
            if(A.val==B.val){
                result = equalTree(A,B);
            }
            if(!result){
                result = isSubStructure(A.left,B);
            }
            if(!result){
                result = isSubStructure(A.right,B);
            }
        }
        return result;
    }

    public boolean equalTree(TreeNode A,TreeNode B){
        if(B==null) return true;
        if(A==null) return false;
        if(A.val!=B.val){
            return false;
        }else{
            return equalTree(A.left,B.left)&&equalTree(A.right,B.right);
        }
    }
}
```

##  面试题27. 二叉树的镜像（）

* 题目描述

    请完成一个函数，输入一个二叉树，该函数输出它的镜像。
    
    **示例 1:**

    >输入：root = [4,2,7,1,3,6,9]  
     输出：[4,7,2,9,6,3,1]
     
    **限制：**
     
    >0 <= 节点个数 <= 1000

* 解法

    交换左右子树，然后递归进左右子树

* 代码

```java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root==null) return null;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        if(root.left!=null){
            mirrorTree(root.left);
        }
        if(root.right!=null){
            mirrorTree(root.right);
        }
        return root;
    }
}
```

##  面试题28. 对称的二叉树（）

* 题目描述

    请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
    
    例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的。
    
    **示例 1:**

    >输入：root = [1,2,2,3,4,4,3]  
     输出：true
     
    **限制：**
     
    >0 <= 节点个数 <= 1000

* 解法

    先判断空值的情况，如果不空判断值是否相等，递归进左右

* 代码

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null){
            return true;
        }
        return judge(root.left,root.right);
    }

    public boolean judge(TreeNode node1,TreeNode node2){
        if(node1==null&&node2==null) return true;
        if(node1==null||node2==null) return false;
        if(node1.val!=node2.val){
            return false;
        }else{
            return judge(node1.left,node2.right)&&judge(node1.right,node2.left);
        }
    }
}
```

##  面试题29. 顺时针打印矩阵（）

* 题目描述

    输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
    
    **示例 1:**

    >输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]  
     输出：[1,2,3,6,9,8,7,4,5]
     
    **限制：**
     
    >0 <= matrix.length <= 100  
     0 <= matrix[i].length <= 100

* 解法

    算出来圈数之后按圈从左到右，从上到下，从右到左，从下到上打印

* 代码

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix==null||matrix.length==0) return new int[0];
        int row = matrix.length;
        int col = matrix[0].length;
        int[] result = new int[row*col];
        int resultIndex = 0;
        int circle = Math.min(row,col)/2+1;
        for(int i=0;i<circle;i++){
            //从左到右打印
            for(int j=i;j<col-i;j++){
                result[resultIndex++] = matrix[i][j];
            }
            if(resultIndex==row*col) break;
            //从上到下打印
            for(int j=i+1;j<row-i;j++){
                result[resultIndex++] = matrix[j][col-i-1];
            }
            if(resultIndex==row*col) break;
            //从右到左打印
            for(int j=i+1;j<col-i;j++){
                result[resultIndex++] = matrix[row-i-1][col-j-1];
            }
            if(resultIndex==row*col) break;
            //从下到上打印
            for(int j=i+1;j<row-i-1;j++){
                result[resultIndex++] = matrix[row-j-1][i];
            }
            if(resultIndex==row*col) break;
        }
        return result;
    }
}
```

##  面试题30. 包含min函数的栈（简单）

* 题目描述

    定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
    
    **示例 1:**

    >MinStack minStack = new MinStack();  
     minStack.push(-2);  
     minStack.push(0);  
     minStack.push(-3);  
     minStack.min();   --> 返回 -3.  
     minStack.pop();  
     minStack.top();      --> 返回 0.  
     minStack.min();   --> 返回 -2.
     
    **限制：**
     
    >各函数的调用总次数不超过 20000 次

* 解法

    两个栈，一个栈正常用，另外一个栈压入最小值

* 代码

```java
class MinStack {

    Stack<Integer> stack;
    Stack<Integer> minStack;
    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }
    
    public void push(int x) {
        stack.push(x);
        if(minStack.isEmpty()){
            minStack.push(x);
        }else if(x<=minStack.peek()){
            minStack.push(x);
        }else if(x>minStack.peek()){
            minStack.push(minStack.peek());
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

##  面试题31. 栈的压入、弹出序列（中等）

* 题目描述

    输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
    
    **示例 1:**

    >输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]  
     输出：true  
     解释：我们可以按以下顺序执行：  
     push(1), push(2), push(3), push(4), pop() -> 4,  
     push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
     
    **限制：**
     
    >0 <= pushed.length == popped.length <= 1000  
     0 <= pushed[i], popped[i] < 1000  
     pushed 是 popped 的排列。

* 解法

    for循环将push压栈，每次压入后看是否能pop

* 代码

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack<Integer> stack = new Stack<>();
        int j=0;
        for(int i=0;i<pushed.length;i++){
            stack.push(pushed[i]);
            while(!stack.isEmpty()&&stack.peek()==popped[j]){
                stack.pop();
                j++;
            }
        }
        if(stack.isEmpty()){
            return true;
        }else{
            return false;
        }
    }
}
```

##  面试题32 - I. 从上到下打印二叉树（中等）

* 题目描述

    从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
    
    **示例 1:**

    >给定二叉树: [3,9,20,null,null,15,7],返回[3,9,20,15,7]
     
    **限制：**
     
    >节点总数 <= 1000

* 解法

    简单的层序遍历，队列即可

* 代码

```java
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root==null) return new int[]{};
        LinkedList<TreeNode> que = new LinkedList<>();
        List<Integer> resultList = new ArrayList<>();
        que.add(root);
        while(!que.isEmpty()){
            TreeNode tmp = que.pop();
            resultList.add(tmp.val);
            if(tmp.left!=null) que.add(tmp.left);
            if(tmp.right!=null) que.add(tmp.right);
        }
        int[] result = new int[resultList.size()];
        for(int i=0;i<resultList.size();i++){
            result[i] = resultList.get(i);
        }
        return result;
    }
}
```

##  （）

* 题目描述

    
    
    **示例 1:**

    >
     
    **限制：**
     
    >

* 解法

    

* 代码

```java

```