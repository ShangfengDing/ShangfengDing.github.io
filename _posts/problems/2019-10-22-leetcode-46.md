---
layout: post
title: leetcode46 java
categories: Prolems
description: leetcode46 java解法
keywords: leetcode
---
## 题目描述

Given a collection of distinct integers, return all possible permutations.
**Example:**  
Input: [1,2,3]  
Output:
[  
  [1,2,3],  
  [1,3,2],  
  [2,1,3],  
  [2,3,1],  
  [3,1,2],  
  [3,2,1]  
]

## 解法

回溯法，将整组数中的所有的数分别与第一个数交换，继续处理后n-1，同样在都与第二个数交换。  
具体在这段代码里指的是，j是实时的第一个数，然后每个数都跟第j个交换。  
交换完了记着在变回原来样子。

## 代码

``` java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> lists = new ArrayList<>();
        helper(lists,nums,0);
        return lists;
    }
    public void helper(List<List<Integer>> lists, int[] nums, int index){
        if(index == nums.length){
            // List<Integer> list = Arrays.asList(nums); 这样不行的，因为里面范型是T，不能是int
            // lists.add(list);
            List<Integer> list = new ArrayList<>();
            for(int num:nums) list.add(num);
            lists.add(list);
            return;
        }
        for(int i=index;i<nums.length;i++){
            swap(nums,i,index);
            helper(lists,nums,index+1);
            swap(nums,index,i);
        }
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
