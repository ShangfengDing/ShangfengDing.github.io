---
layout: post
title: LeetCode
categories: Prolems
description: LeetCode
keywords: leetcode,刷题
---

目录

* TOC
{:toc}

## 42 能装多少雨水 难

* 题目描述

    Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
    ![leetcode42](/images/posts/problems/leetcode42/rainwatertrap.png)

    **Example:**

    >Input: [0,1,0,2,1,0,1,3,2,1,2,1]  
    Output: 6

* 解法

    找到中间最高的分别往两边看，最左边和最右边分别往中间最高的走，这样每次两边都是最高的一定能把中间围起来一个面积。这样时间复杂度也只是O(2n)

* 代码

    ``` java
    class Solution {
        //找到中间最高了，
        public int trap(int[] height) {
            if(height.length==0) return 0;
            int maxHeight = height[0];
            int maxIndex = 0;
            int res = 0;
            for(int i=0;i<height.length;i++){
                if(height[i]>maxHeight){
                    maxHeight = height[i];
                    maxIndex = i;
                }
            }
            //从左边开始
            int maxLeft = height[0];
            for(int i=1;i<maxIndex;i++){
                if(maxLeft>height[i]){
                    res+=maxLeft-height[i];
                }else{
                    maxLeft = height[i];
                }
            }
            //从右边开始
            int maxRight = height[height.length-1];
            for(int i=height.length-2;i>maxIndex;i--){
                if(maxRight>height[i]){
                    res+=maxRight-height[i];
                }else{
                    maxRight = height[i];
                }
            }
            return res;
        }
    }
    ```

## 46 数组的全排列 中

* 题目描述

    Given a collection of distinct integers, return all possible permutations.

    **Example:**

    >Input: [1,2,3]  
    Output:
    [  
    [1,2,3],  
    [1,3,2],  
    [2,1,3],  
    [2,3,1],  
    [3,1,2],  
    [3,2,1]  
    ]

* 解法

    回溯法，将整组数中的所有的数分别与第一个数交换，继续处理后n-1，同样在都与第二个数交换。  
    具体在这段代码里指的是，j是实时的第一个数，然后每个数都跟第j个交换。  
    交换完了记着在变回原来样子。

* 代码

    ``` java
    class Solution {
        public List<List<Integer>> permute(int[] nums) {
            List<List<Integer>> lists = new ArrayList<>();
            helper(lists,nums,0);
            return lists;
        }
        public void helper(List<List<Integer>> lists, int[] nums, int index){
            if(index == nums.length){
                // List<Integer> list = Arrays.asList(nums); 这样不行的，因为里面范型是T，不能是int
                // lists.add(list);
                List<Integer> list = new ArrayList<>();
                for(int num:nums) list.add(num);
                lists.add(list);
                return;
            }
            for(int i=index;i<nums.length;i++){
                swap(nums,i,index);
                helper(lists,nums,index+1);
                swap(nums,index,i);
            }
        }
        public void swap(int[] nums,int i,int j){
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
    ```

## 48 矩阵的旋转 中

* 题目描述

    You are given an n x n 2D matrix representing an image.

    Rotate the image by 90 degrees (clockwise).

    **NOTE:**

    You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

    **Example:**

    >Given input matrix =  
    [  
    [1,2,3],  
    [4,5,6],  
    [7,8,9]  
    ],  

    rotate the input matrix in-place such that it becomes:  
    [  
    [7,4,1],  
    [8,5,2],  
    [9,6,3]  
    ]

* 解法

    核心如下图，找到旋转规律就很容易了。  
    在遍历二维数组的时候要对正方形从最外圈向最里圈走
    ![leetcode42](/images/posts/problems/leetcode48/leetcode48.png)

* 代码

    ``` java
    class Solution {
        public void rotate(int[][] matrix) {
            int length = matrix.length;
            for(int i=0;i<length/2;i++){ //想象i就是第一行的index，所以走一半就到中间了
                for(int j=i;j<length-i-1;j++){ //j的起始是i，j=i即是对角线，结束的时候走到少i个的地方，并且最后一个格是上一溜转出来的所以还要在减1
                    int temp = matrix[i][j];
                    matrix[i][j] = matrix[length-j-1][i];
                    matrix[length-j-1][i] = matrix[length-i-1][length-j-1];
                    matrix[length-i-1][length-j-1] = matrix[j][length-i-1];
                    matrix[j][length-i-1] = temp;
                }
            }
        }
    }
    ```

## 49 按照字典序分组 中

* 题目描述

    Given an array of strings, group anagrams together.

    **Example:**

    >Input: ["eat", "tea", "tan", "ate", "nat", "bat"],  
    Output:
    [  
    ["ate","eat","tea"],  
    ["nat","tan"],  
    ["bat"]  
    ]

* 解法

    思路很简单了，创一个map，把数组中每个字符串排序，放到map中就可以了。

* 代码

    ``` java
    class Solution {
        public List<List<String>> groupAnagrams(String[] strs) {
            HashMap<String,List<String>> map = new HashMap<>();
            for(int i=0;i<strs.length;i++){
                char[] cs = strs[i].toCharArray();
                Arrays.sort(cs);
                String s = String.valueOf(cs);
                List<String> list = map.get(s);
                if(list!=null){
                    list.add(strs[i]);
                }else{
                    list = new LinkedList<>();
                    list.add(strs[i]);
                    map.put(s,list);
                }
            }
            return new ArrayList<>(map.values());
        }
    }
    ```

## 55 弹跳游戏 中

* 题目描述

    Given an array of non-negative integers, you are initially positioned at the first index of the array.  
    Each element in the array represents your maximum jump length at that position.  
    Determine if you are able to reach the last index.

    **Example:**

    >Input: [2,3,1,1,4]  
    Output: true  
    Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

* 解法

    *最早的直观想法：每个位置跳到它能跳的位置，一直到有一个能跳到尽头就结束，结果在最后几个例子中超时了。*

    **动态规划**，先创建一个数组标记全为未知，之后从后往前，走挨个标记

    **贪心算法**，从0开始计算能到的最远的点，只要在能到和数组长度内，就一直网上算最远能到的点。

* 代码

    ``` java
    //最早的超时代码
    // class Solution {
    //     public boolean canJump(int[] nums) {
    //         if(nums.length == 1) return true;
    //         return jump(nums, 0);
    //     }
    //     public boolean jump(int[] nums, int position){
    //         if(position+nums[position]>=nums.length-1) return true;
    //         if(nums[position]==0) return false;
    //         for(int i=nums[position];i>0;i--){
    //             if(jump(nums, position+i)) return true;
    //         }
    //         return false;
    //     }
    // }

    //动态规划 O(n2)

    // class Solution {
    //     public boolean canJump(int[] nums) {
    //         int[] dp = new int[nums.length]; // 认为值为0，则未知，每个点表示从这个点能不能到终点
    //         dp[dp.length-1] = 1;// 值为1就是能到
    //         for(int i=dp.length-2;i>=0;i--){
    //             int maxJump = Math.min(i+nums[i],nums.length);
    //             for(int j=i+1;j<=maxJump;j++){
    //                 if(dp[j]==1){
    //                     dp[i]=1;
    //                     break;
    //                 }
    //             }
    //             if(dp[i]==0) dp[i]=-1;
    //         }
    //         return dp[0]==1?true:false;
    //     }
    // }

    // 贪心算法 O(n)

    class Solution {
        public boolean canJump(int[] nums) {
            int reach = nums[0];
            for(int i=1;reach>=i&&i<nums.length;i++){ //i是当前的位置
                reach = Math.max(reach,i+nums[i]);
            }
            return reach>=(nums.length-1)?true:false;
        }
    }
    ```

## 56 区间的融合 中

* 题目描述

    Given a collection of intervals, merge all overlapping intervals.

    **Example:**

    >Input: [[1,3],[2,6],[8,10],[15,18]]  
    Output: [[1,6],[8,10],[15,18]]  
    Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].

* 解法

    O(n)，挨着比就是了，就是要注意细节，比如先要排序，[1,10]是包含[2,5]这种情况。

* 代码

    ``` java
    class Solution {
        public int[][] merge(int[][] intervals) {
            if (intervals.length <= 1) {
                return intervals;
            }
            Arrays.sort(intervals, new Comparator<int[]>(){
                public int compare(int[] i1,int[]i2){
                    return i1[0]-i2[0];
                }
            });
            //Arrays.sort(intervals, Comparator.comparingInt(o -> o[0])); 函数式接口速度远慢于原始的比较器
            List<int[]> list = new ArrayList<>();
            int i = 0;
            while(i < intervals.length){
                int[] in = new int[2];
                in[0] = intervals[i][0];
                in[1] = intervals[i][1];
                while(i<intervals.length-1 && in[1]>=intervals[i+1][0]){
                    in[1] = Math.max(intervals[i+1][1],in[1]);
                    i++;
                }
                i++;
                list.add(in);
            }
            return list.toArray(new int[0][]);
        }
    }
    ```

## 62 机器人唯一的路径 中

* 题目描述

    A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).  
    The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).  
    How many possible unique paths are there?
    ![robot example](/images/posts/problems/leetcode62/robot_maze.png)  
    *Above is a 7 x 3 grid. How many possible unique paths are there?*

    **Example:**

    >Input: m = 3, n = 2  
    Output: 3  
    Explanation:  
    From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:  
    1.Right -> Right -> Down  
    2.Right -> Down -> Right  
    3.Down -> Right -> Right  

* 解法

    最简单不用想的动态规划很容易了，数值含义是从起点到这个点的方法数，递推公式是左边值+上边值

    第二种是对空间的优惠，每个点的值是它上面点+他左边点，由此可以想到数组是不清空的，那么dp[n]其实就是它上面点的路线值，dp[n-1]就是他左边的值。于是dp[n] = dp[n]+dp[n-1]

* 代码

    ``` java
    class Solution {
        // 动态规划的核心是找我的动态规划的数字代表什么，像本题这个数字就是从[0,0]到这个点的路径数量
        // 第二个重点就是递推公式，他的递推公式就是左边+上边
        public int uniquePaths(int m, int n) {
            int[][] dp = new int[m][n];
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    if(i==0||j==0) {
                        dp[i][j] = 1;
                    }else{
                        dp[i][j] = dp[i-1][j]+dp[i][j-1];
                    }
                }
            }
            return dp[m-1][n-1];
        }

        public int uniquePaths2(int m, int n) {
        int[] dp = new int[n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0||j==0) {
                    dp[j] = 1;
                }else{
                    dp[j] = dp[j]+dp[j-1]; // 上面+左边
                }
            }
        }
        return dp[n-1];
    }
    }
    ```

## 64 最短路径和 中

* 题目描述

    Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.  
    **Note: You can only move either down or right at any point in time.**

    **Example:**

    >Input:  
    [  
    [1,3,1],  
    [1,5,1],  
    [4,2,1]  
    ]  
    Output: 7  
    Explanation: Because the path 1→3→1→1→1 minimizes the sum.

* 解法

    依然是动态规划，数值是到这个点的最短路径，这样递推公式就是上下的最短路径+这个点的路径

* 代码

    ``` java
    class Solution {
        public int minPathSum(int[][] grid) {
            int m = grid.length;
            int n = grid[0].length;
            //同样动态规划，每个点的值是到这个点的最短路径值
            int[][] dp = new int[grid.length][grid[0].length];
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    if(i==0&&j==0) dp[0][0] = grid[0][0];
                    else if(i==0){
                        dp[0][j] = dp[0][j-1] + grid[0][j];
                    }
                    else if(j==0){
                        dp[i][0] = dp[i-1][0] + grid[i][0];
                    }else{
                        dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
                    }
                }
            }
            return dp[m-1][n-1];
        }
    }
    ```

## 70 爬梯子 简单

* 题目描述

    You are climbing a stair case. It takes n steps to reach to the top.  
    Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

    Note: Given n will be a positive integer.

    **Example:**

    >Input: 3  
    Output: 3  
    Explanation: There are three ways to climb to the top.  
    1.1 step + 1 step + 1 step  
    2.1 step + 2 steps  
    3.2 steps + 1 step  

* 解法

    最简单的思想就是每一步可以看作是减一步的数量加上1（这次再走一步），或是减两部的数量加上一（相当于一次再走两步），最后也就是斐波那契数列了。

* 代码

    ``` java
    class Solution {
        //最直观的递归写法，但每次都要从头算，太慢了。
        public int climbStairs(int n) {
            if(n<=1) return 1;
            return climbStairs(n-1) + climbStairs(n-2);
        }
        //可以说算是动态规划，但其实就是找了个数组存一下中间结果罢了
        public int climbStairs2(int n) {
            int[] dp = new int[n+1];
            dp[0]=1; // 可以省略
            dp[1]=1;
            for(int i=2;i<=n;i++){
                dp[i] = dp[i-1]+dp[i-2];
            }
            return dp[n];
        }
    }
    ```

## 72 替换单词最小编辑距离 难

* 题目描述

    Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

    You have the following 3 operations permitted on a word:

    Insert a character  
    Delete a character  
    Replace a character

    **Example:**

    >Input: word1 = "horse", word2 = "ros"  
    Output: 3  
    Explanation:  
    horse -> rorse (replace 'h' with 'r')  
    rorse -> rose (remove 'r')  
    rose -> ros (remove 'e')

* 解法

    动态规划，dp[i][j]代表从0到i，j的这个两个词需要多少步能变成相同。所以dp[0][j]和dp[i][0]的值均为j或i（纯删除）。之后如果字母相同，证明无需调整，dp[i+1][j+1]=dp[i][j]。如果字母不相同会分三种情况：

    * i的删掉一个
    * j的删掉一个
    * i和j的作替换

    所以dp[i+1][j+1]就变成了取dp[i][j+1],dp[i+1][j],dp[i][j]的最小值。

* 代码

    ``` java
    class Solution {
        public int minDistance(String word1, String word2) {
            int[][] dp = new int[word1.length()+1][word2.length()+1];
            if(word1.length()==0) return word2.length();
            if(word2.length()==0) return word1.length();
            for(int i = 0;i<=word1.length();i++){
                dp[i][0] = i;
            }
            for(int i = 0;i<=word2.length();i++){
                dp[0][i] = i;
            }
            for(int i =1;i<=word1.length();i++){
                for(int j=1;j<=word2.length();j++){
                    if(word1.charAt(i-1)==word2.charAt(j-1)){
                        dp[i][j] = dp[i-1][j-1];
                    }else{
                        dp[i][j] = 1+Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]));
                    }
                }
            }
            return dp[word1.length()][word2.length()];
        }
    }
    ```

## 75 数组中相同数字分组 中

* 题目描述

    Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

    Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

    **Note**: You are not suppose to use the library's sort function for this problem.

    **Example:**

    >Input: [2,0,2,1,1,0]  
    Output: [0,0,1,1,2,2]

    **Follow up:**

    >A rather straight forward solution is a two-pass algorithm using counting sort.  
    First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.  
    Could you come up with a one-pass algorithm using only constant space?

* 解法

    要利用好他就0 1 2三个数排序的特点，也就证明2个指针足以分隔开三个数。第一个指针分割0,1，指针指名的是第一个非0的数。第二个指针分割1,0，指针指的是最后一个分2的数。

* 代码

    ``` java
    class Solution {
        public void sortColors(int[] nums) {
            int left = 0;// 这是第一个非0的位置
            int right = nums.length - 1;// 这是最后一个非2的位置
            int i = 0;
            while(i<=right){
                if(nums[i]==0){
                    swap(nums, i,left);
                    left++;
                    i++;
                }else if(nums[i]==1){
                    i++;
                }else{
                    swap(nums,i,right);
                    right--;
                    //这块不i++，因为后面的数字没有整理过，过来的可能是0或1
                }
            }
        }
        public void swap(int[] nums,int i1, int i2){
            int temp = nums[i1];
            nums[i1] = nums[i2];
            nums[i2] = temp;
        }
    }
    ```

## 76 含有字符串的最小序列 难

* 题目描述

    Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

    **Example:**

    >Input: S = "ADOBECODEBANC", T = "ABC"  
    Output: "BANC"

* 解法

    使用一个map来保存带找的字符串，并用一个count记录总长度。先将带找字符串全部输入到map中然后遍历长字符串。遇到一个map中有的数便-1。但注意count在map减到小于0后就不再减了，因为证明已经全部减完了，之后的是重复的。当count归0后，证明已经全部匹配到了，从头开始搜索。同理map大于0时才开始计数。在长度中比较选最短的即可。

* 代码

    ``` java
    class Solution {
        public String minWindow(String s, String t) {
            char[] ss=s.toCharArray();
            char[] ts=t.toCharArray();
            String result="";
            int count = ts.length;
            HashMap<Character,Integer> map=new HashMap<Character,Integer>();
            for(int i=0;i<ts.length;i++){
                if(!map.containsKey(ts[i])){
                    map.put(ts[i],0);
                }
                map.put(ts[i],map.get(ts[i])+1);
            }
            int left=0;
            for(int i=0;i<ss.length;i++){
                Character temp = ss[i];
                if(map.containsKey(temp)){
                    int num = map.get(temp);
                    if(num > 0){ //只有当map里这个字母还有没匹配的时候，就减，防止重复太多多减，如果是小于等于0时，则这个字母之前已经匹配完了，但还有重复字母，因为只取最后一个，底下的会加回来，当底下再加回0时，证明到了最后一个了
                        count--;
                    }
                    map.put(temp,num-1);
                }
                if(count==0){ //所有的都匹配到了
                    while(left<=i && count == 0){//一直找到最左边，如果有一个出现了字符，证明从这个地方字符就是最左边了，就跳出循环，等着再次匹配
                        Character tempLeft = ss[left];
                        if(map.containsKey(tempLeft)){
                            int num = map.get(tempLeft);
                            if(num>=0){
                                count++;
                                if(result.equals("")||i-left+1<result.length())
                                result = s.substring(left,i+1);
                            }
                            map.put(tempLeft,num+1); // +1时都会进行的，而count++不是，因为对于前面一大堆重复数字这种情况，一直加到1的那个才是最近的
                        }
                        left++;
                    }
                }
            }
            return result;
        }
    }
    ```